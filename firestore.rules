/**
 * @file Firestore Security Rules
 * @core-philosophy This ruleset enforces a shared access model for ServerDetails and VpsConfigurations,
 *  where access is granted based on the presence of a user's ID in a 'members' map on the document.
 *  This design avoids complex queries and ensures that authorization checks are fast and efficient.
 * @data-structure
 *  - /serverDetails/{serverDetailId}: Stores server details, including a 'members' map for access control.
 *  - /serverDetails/{serverDetailId}/vpsConfigurations/{vpsConfigurationId}: Stores VPS configurations, also including a 'members' map and denormalized serverDetails.id.
 * @key-security-decisions
 *  - User listing is disabled for all collections.
 *  - All write operations require the user to be authenticated and present in the document's 'members' map.
 *  - Data validation is relaxed to allow for rapid prototyping, but relational integrity is enforced
 *    by ensuring that the 'serverDetails.id' field in VpsConfiguration matches the parent document's ID.
 *  - To ensure rules work correctly and efficiently, all authorization data is denormalized onto the documents themselves.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to the serverDetails collection.  Access is granted to members listed in the document's 'members' map.
     * @path /serverDetails/{serverDetailId}
     * @allow (get, list) User with auth.uid 'user_abc' can read if serverDetails/{serverDetailId} has {members: {'user_abc': 'editor'}}.
     * @allow (create, update, delete) User with auth.uid 'user_abc' can write if serverDetails/{serverDetailId} has {members: {'user_abc': 'editor'}}.
     * @deny (get, list) User with auth.uid 'user_xyz' cannot read if serverDetails/{serverDetailId} does not have {members: {'user_xyz': 'editor'}}.
     * @deny (create, update, delete) User with auth.uid 'user_xyz' cannot write if serverDetails/{serverDetailId} does not have {members: {'user_xyz': 'editor'}}.
     * @principle Implements a shared access control pattern based on a 'members' map.
     */
    match /serverDetails/{serverDetailId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is a member of the document
      function isMember(members) {
        return isSignedIn() && members[request.auth.uid] != null;
      }

      // Helper function to check if the user is the owner of the document and the document exists
      function isExistingMember(members) {
        return isMember(members) && resource != null;
      }

      // Helper function to get the members map from the incoming request data
      function getMembers() {
        return request.resource.data.members;
      }

      // Read rules
      allow get: if true;
      allow list: if true;

      // Write rules
      allow create: if isSignedIn() && isMember(getMembers());
      allow update: if isExistingMember(resource.data.members);
      allow delete: if isExistingMember(resource.data.members);
    }

    /**
     * @description Controls access to the vpsConfigurations subcollection. Access is granted to members listed in the document's 'members' map.
     * @path /serverDetails/{serverDetailId}/vpsConfigurations/{vpsConfigurationId}
     * @allow (get, list) User with auth.uid 'user_abc' can read if vpsConfigurations/{vpsConfigurationId} has {members: {'user_abc': 'editor'}}.
     * @allow (create, update, delete) User with auth.uid 'user_abc' can write if vpsConfigurations/{vpsConfigurationId} has {members: {'user_abc': 'editor'}}.
     * @deny (get, list) User with auth.uid 'user_xyz' cannot read if vpsConfigurations/{vpsConfigurationId} does not have {members: {'user_xyz': 'editor'}}.
     * @deny (create, update, delete) User with auth.uid 'user_xyz' cannot write if vpsConfigurations/{vpsConfigurationId} does not have {members: {'user_xyz': 'editor'}}.
     * @principle Implements a shared access control pattern based on a 'members' map. Enforces relational integrity by matching serverDetailId.
     */
    match /serverDetails/{serverDetailId}/vpsConfigurations/{vpsConfigurationId} {
       // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is a member of the document
      function isMember(members) {
        return isSignedIn() && members[request.auth.uid] != null;
      }

      // Helper function to check if the user is the owner of the document and the document exists
      function isExistingMember(members) {
        return isMember(members) && resource != null;
      }

      // Helper function to get the members map from the incoming request data
      function getMembers() {
        return request.resource.data.members;
      }

      // Read rules
      allow get: if true;
      allow list: if true;

      // Write rules
      allow create: if isSignedIn() && isMember(getMembers()) && request.resource.data.serverDetails == serverDetailId;
      allow update: if isExistingMember(resource.data.members) && request.resource.data.serverDetails == serverDetailId;
      allow delete: if isExistingMember(resource.data.members);
    }
  }
}